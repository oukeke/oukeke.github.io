<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于ping和nslookup百度网站域名的一些问题和思考记录]]></title>
    <url>%2F2020%2F01%2F29%2Fping-nslookup%2F</url>
    <content type="text"><![CDATA[命令使用nslookup1nslookup www.baidu.com 返回结果：123456789Server: 192.168.3.1Address: 192.168.3.1#53Non-authoritative answer:www.baidu.com canonical name = www.a.shifen.com.Name: www.a.shifen.comAddress: 14.215.177.38Name: www.a.shifen.comAddress: 14.215.177.39 1nslookup baidu.com 返回结果12345678Server: 192.168.3.1Address: 192.168.3.1#53Non-authoritative answer:Name: baidu.comAddress: 220.181.38.148Name: baidu.comAddress: 39.156.69.79 ping1ping www.baidu.com 返回结果1234PING www.a.shifen.com (14.215.177.38): 56 data bytes64 bytes from 14.215.177.38: icmp_seq=0 ttl=56 time=16.857 ms64 bytes from 14.215.177.38: icmp_seq=1 ttl=56 time=17.717 ms... 1ping baidu.com 返回结果1234PING baidu.com (220.181.38.148): 56 data bytes64 bytes from 220.181.38.148: icmp_seq=0 ttl=53 time=46.202 ms64 bytes from 220.181.38.148: icmp_seq=1 ttl=53 time=53.407 ms... 相关思考为什么www.baidu.com会解析成 www.a.shifen.comwww.baidu.com作为cname记录（相当于别名），在dns服务器中配置了www.baidu.com到www.a.shifen.com的映射记录。而www.a.shifen.com是作为A（address）记录，映射到了真实的IP信息。 nslookup显示www.baidu.com 的canonical name = www.a.shifen.com.，意味着当前查询的域名是另一个域名的跳转。 解析www.baidu.comIP地址的过程：当我们查询www.baidu.com的地址时，会依次去本地host，本地dns，根域DNS服务器，.com服务器，baidu.com服务器查询。而在baidu.com域服务器里查找到www对应一条c记录，将www.baidu.com映射到www.a.shifen.com。所以会再次去.com域进行对shifen.com进行查询，以同样的方式，最终查到了14.215.177.38这个地址。 浏览器可以访问www.baidu.com而不能访问www.a.shfen.com这是因为http请求的时候，会把请求的url写入请求头，服务器会拒绝带www.a.shifen.com域名的请求。 我们直接访问14.215.177.38，发现可以准确跳转到对应的页面。说明百度的服务器就在14.215.177.38这个服务器上，也说明服务器是支持IP地址直接访问的。但是这样访问的话是只能有http的访问，不能使用登录相关的功能了。使用https://4.215.177.38 也没有办法，因为证书的域名是baidu.com的，不认识这一个IP地址。 访问14.215.177.38时，使用点击登录并抓包，可以发现返回403错误。 导致403错误的主要原因 你的IP被列入黑名单。 你在一定时间内过多地访问此网站（一般是用采集程序），被防火墙拒绝访问了。 网站域名解析到了空间，但空间未绑定此域名。 你的网页脚本文件在当前目录下没有执行权限。 在不允许写/创建文件的目录中执行了创建/写文件操作。 以http方式访问需要ssl连接的网址。 浏览器不支持SSL 128时访问SSL 128的连接。 在身份验证的过程中输入了错误的密码。 DNS解析错误，手动更改DNS服务器地址。 连接的用户过多，可以过后再试。 服务器繁忙，同一IP地址发送请求过多，遭到服务器智能屏蔽。 baidu.com和www.baidu.com解析得IP地址不同，如何得到同样的结果使用curl -v来查看通信的整个过程 curl -v www.baidu.com得到跟www.baidu.com建立http连接。在末尾返回了网页的基本信息html代码: &lt;!DOCTYPE html&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=百度一下 class=&quot;bg s_btn&quot;&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;新闻&lt;/a&gt; &lt;a href=http://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;地图&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;视频&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;贴吧&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;登录&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(&apos;&lt;a href=&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&apos;+ encodeURIComponent(window.location.href+ (window.location.search === &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come=1&quot;)+ &apos;&quot; name=&quot;tj_login&quot; class=&quot;lb&quot;&gt;登录&lt;/a&gt;&apos;);&lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=&quot;display: block;&quot;&gt;更多产品&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=ftCon&gt; &lt;div id=ftConw&gt; &lt;p id=lh&gt; &lt;a href=http://home.baidu.com&gt;关于百度&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p id=cp&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;使用百度前必读&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;意见反馈&lt;/a&gt;&amp;nbsp;京ICP证030173号&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; curl -v baidu.com得到的末尾则是： &lt;html&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt; &lt;/html&gt; 即它会使浏览器刷新到www.baidu.com。 因此这里使用baidu.com解析出来的IP也可以一样访问到http://www.baidu.com/ 访问http://…变成https://…上面我们可以看到访问的是http://www.baidu.com，但最后发现变成访问https://www.baidu.com。这种应该是apache服务器将域名rewrite，转换成https链接进行访问，但是我们前面说了使用www.baidu.com解析的IP是不能进行登录等操作的，即没有转化成https。是因为rewriterule是对请求的url进行正则匹配的，所以ip地址是无法进行rewrite的。 而其他网站也存在没有后端服务器限制强制转换的情况，如果出现http变为https的情况，可以检查一下自己浏览器的NAS设置。 一个域名对应多个IP地址比如通过nslookup查看的可以得知这两个域名都有两个IP地址。这样可以DNS负载均衡。每一次域名解析都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，记录中配置的多个服务器就可以构成一个集群。同时该DNS还支持基于地理位置的域名解析，即会将域名解析成距离用户地理最近的一个服务器地址，这样就可以加速用户访问，改善性能，所以不同地区解析出来的域名对应的IP地址应该都是不同的。 但是单纯用DNS来进行负载均衡的话，也有一些缺点：由于DNS的负载均衡只是采用最简单的轮询算法，不能区分出服务器的性能差别，也不能判断服务器现在的状态，所以负载均衡的效果并不好。所以大型网站一般都是使用DNS域名解析，利用域名解析来做第一级的负载均衡。域名解析得到的服务器并不是实际提供服务的物理服务器，而是同样具有内在负载均衡功能的内部服务器。这组内部负载均衡服务器再进行进一步的负载均衡，将请求发到对应的真实服务器上。]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树和B+树]]></title>
    <url>%2F2020%2F01%2F17%2FBtrees%2F</url>
    <content type="text"><![CDATA[B树（也称为B-树）基本定义 是一颗多路平衡查找树 每个节点最多有m-1个关键字（可以存在的键值对） 根结点最少可以只有1个关键字 非根结点至少要有m/2个关键字 每个节点中的关键字都按从小到大的顺序排列，每个关键字的左子树的所有关键字都小于它，而右子树的所有关键字都大于它。 所有的叶子节点都位于同一层，或者说根结点到叶子结点的距离都相同 每个节点都有索引和数据，即key和value总结： 根结点的关键字的范围在1 ≤ k ≤ m-1，非根结点的关键字范围在m/2 ≤ k ≤ m-1 （描述一颗b树需要指定它的阶数，阶数表示一个节点最多可以有多少孩子节点，一般用m表示。） B树插入判断当前key的节点是不是小于m-1，如果是，则直接插入；如果不是，则将节点中间的key将这个节点分为左右两部分，中间的节点放在父节点即可。 B树删除分情况分析： 删除叶子结点的元素，删除之后，叶子结点元素仍然大于m/2，则可以直接删除。 对于非叶子节点的删除，需要用后继元素覆盖要删除的key，然后在后继key所在的子支中删除该后继key。 如果删除叶子结点，删除后叶子节点元素小于m/2，就应该向兄弟元素借：如果此时兄弟节点的元素大于m/2，也即是兄弟节点的元素比最小值m/2还要多，将父节点元素移动到该节点，将兄弟元素移动到父节点。 如果删除叶子结点，删除后叶子节点元素小于m/2，且兄弟节点的元素也不大于m/2 B+树基本定义与B树的相同点： 根结点至少有1个关键字 非根结点范围m/2 ≤ k ≤ m-1与B树的不同点： b+树有两种类型的节点：内部节点（索引节点，非叶子结点）和叶子结点。内部节点不存储关键字的值，只存储索引，值都存储在叶子结点。 内部节点中key都按从小到大排序，对于内部节点中的一个key，它左子树中的key都比他小，右子树中的key都比他大。叶子节点中的数据也按照key的大小排序。 每个叶子结点都有相邻叶子结点的指针，叶子结点本身依依关键字的大小自小而大顺序链接 父节点有右孩子第一个元素的索引 B+树插入当节点元素大于m-1时，按中间元素分成两部分，中间元素分裂到父节点当作索引存储，但是本身中间元素还是分裂右边这一部分的。 B+树删除叶子结点有指针的存在，所以借元素不需要通过父节点，可以直接向兄弟节点借（前提是兄弟节点的元素大于m/2），然后更新父节点的索引。如果兄弟节点的元素个数不大于m/2，则将当前节点与兄弟节点合并，并删除父节点中的key。 B+树相较于B-树的优势 单一节点存储的元素更多，是的查询的IO次数减少，因此更适合作为数据库的底层数据结构（MySql） 所有的查询都要找到叶子结点，查询性能稳定，而b树每个节点都可能找到数据，所以不稳定 所有叶子结点形成一个有序链表，更便于查找 学习总结这里的插入和删除都要自己动手画一下流程，这样记忆才会比较深刻。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于static关键字]]></title>
    <url>%2F2020%2F01%2F17%2Fstatic%2F</url>
    <content type="text"><![CDATA[首先将C++的几个性质看一下，可以支持面向对象编程，而同时也有部分继承C语言的面向过程的内容。 那我们则从面向对象和面向过程两个方面来看static这个关键字的用处。 1.面向对象1.1.静态成员变量定义类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员。 特点 静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新； 因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它； 静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行。否则，编译能通过，链接不能通过。在Example 5中，语句int Myclass::Sum=0;是定义并初始化静态成员变量。初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。 static 成员变量和普通 static 变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。 静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞- 类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞- 类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。 静态数据成员和普通数据成员一样遵从public,protected,private访问规则； 如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ； sizeof 运算符不会计算 静态成员变量。 1234class CMyclass&#123; int n; static int s;&#125;; //则sizeof（CMyclass）等于4 何时采用静态数据成员设置静态成员（变量和函数）这种机制的目的是将某些和类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于理解和维护。如果想在同类的多个对象之间实现数据共享，又不要用全局变量，那么就可以使用静态成员变量。也即，静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。节省存储空间且当利息要修改的时候只用修改一次。 相较全局变量的优点 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能。 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能。 1.2.静态成员函数静态成员函数为类服务而不是为某一个类的具体对象服务。静态成员函数与静态成员变量一样，都是类的内部实现，属于类定义的一部分。普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象。 普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体地属于类的某个具体对象的。当函数被调用时，系统会把当前对象的起始地址赋给 this 指针。通常情况下，this是缺省的。如函数fn()实际上是this-&gt;fn()。 与普通函数相比，静态成员函数属于类本身，而不作用于对象，因此它不具有this指针。正因为它没有指向某一个对象，所以它无法访问属于类对象的非静态成员变量和非静态成员函数，它只能调用其余的静态成员函数和静态成员变量。从另一个角度来看，由于静态成员函数和静态成员变量在类实例化之前就已经存在可以访问，而此时非静态成员还是不存在的，因此静态成员不能访问非静态成员。 特点 出现在类体外的函数定义不能指定关键字static； 静态成员之间可以相互访问，即静态成员函数（仅）可以访问静态成员变量、静态成员函数； 静态成员函数不能访问非静态成员函数和非静态成员变量； 非静态成员函数可以任意地访问静态成员函数和静态数据成员 由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快； 调用静态成员函数，两种方式：– 通过成员访问操作符(.)和(-&gt;)，也即通过类对象或指向类对象的指针调用静态成员函数。– 直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）。也即，静态成员不需要通过对象就能访问。 拷贝构造函数的问题在使用包含静态成员的类时，有时候会调用拷贝构造函数生成临时的隐藏的类对象，而这个临时对象在消亡时会调用析构函数有可能会对静态变量做操作（例如total_num–），可是这些对象在生成时却没有执行构造函数中的total_num++的操作。解决方案是为这个类写一个拷贝构造函数，在该拷贝构造函数中完成total_num++的操作。 2.面向过程2.1.静态全局变量在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。 特点 该变量在全局数据区分配内存； 未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）； 静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； 静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。 补充：对于一个完整的程序，在内存中的分布情况如下：【代码区】【全局数据区】【堆区】【栈区】，一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。自动变量一般会随着函数的退出而释放空间，而全局数据区的数据并不会因为函数的退出而释放空间。 定义静态全局变量的好处 静态全局变量不会被其他文件所用 其他文件可以定义相同变量名的变量 因此，在一个文件中，静态全局变量和全局变量功能相同；而在两个文件中，要使用同一个变量，则只能使用全局变量而不能使用静态全局变量。 2.2.静态局部变量在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。 通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。 但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，这给程序的维护带来不便。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。 特点 静态局部变量在全局数据区分配内存； 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0； 静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束； 2.3.静态函数在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。 好处 静态函数不能被其它文件所用； 其它文件中可以定义相同名字的函数，不会发生冲突；]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[purpose]]></title>
    <url>%2F2020%2F01%2F17%2Fpurpose%2F</url>
    <content type="text"><![CDATA[将网站彻底用来记录我自己的学习好了。 加油！有缘看到这个网站的人也是！]]></content>
  </entry>
</search>
